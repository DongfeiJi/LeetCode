/*
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

c++刷题答案整理：https://github.com/DongfeiJi/LeetCode
经典暴力搜索，回溯法,时间复杂度接近于2的n次方，过不掉
因此考虑动态规划算法，将原问题拆解为子问题
考虑：对于爬到第i阶，与哪些阶有关？只能是第i-1阶与第i-2阶
因此，爬到第i阶的爬法数量就等于爬到第i-1阶爬法数量+第i-2阶爬法数量
这里面找子问题，相当于找关系，结合题意
算法：(命名最好用dp，动态规划，很专业哦)
1，设置一个递推数组dp[0...n],dp[i]代表到达第i阶的爬法，初始化为0
2，设置到达第1阶，有1种爬法，到达第二阶有2种爬法
3，利用i循环递推从第3阶至第n阶结果：
    到达第i阶爬法=第i-1阶爬法+第i-2阶爬法
dp0=0；dp1=1；dp2=2;dp3=dp1+dp2=3;dpi=dp(i-1)+dp(i-2)....
 
dp总结：
1，确认原问题与子问题，原问题是求n阶台阶走法，子问题是求n-1阶台阶走法，n-2。。。
2，确认状态，本题目状态单一，第i个状态就是第i阶台阶的走法
3，确认边界状态的值，因为边界不一定满足递推式，本题就是dp1，dp2
4，确定状态转移方程，即找到原问题，与最相近的两个子问题之间的递推关系，本题dpi=dpi-1 + dpi-2（i大于等于3）
*/
class Solution {
public:
    int jumpFloor(int number) {
        vector<int> dp(number + 1, 0);//dp数组，因为直接用dp[i]表示当前状态，没有dp[0]，所以数组容量+1
        dp[1] = 1;
        dp[2] = 2;//边界
        for(int i = 3; i <= number; i++){//利用i循环递推从第3阶至第n阶结果：
            dp[i] = dp[i - 1] + dp[i - 2];//状态转移方程，到达第i阶爬法=第i-1阶爬法+第i-2阶爬法
        }
        return dp[number];//返回结果
    }
};