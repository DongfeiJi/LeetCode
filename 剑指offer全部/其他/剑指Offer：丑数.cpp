/*
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，
因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

https://blog.csdn.net/juanmengmu2595/article/details/80102035
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但7、14不是，因为它们包含质因子7。 
习惯上我们把1当做是第一个丑数。
前20个丑数为：1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36。

思考：前面的丑数很好枚举，本题目重点在于维护一个有序的丑数数组，暴力法就是每生成一个丑数，都对前面所有的进行判断，
但是过于暴力。既然有p<q, 那么2*p<2*q，那么“我如t2”在前面比你小的数都没被选上，你后面生成新的丑数一定比“我”大吧，
那么你乘2生成的丑数一定比我乘2的大吧，那么在我选上之后你才有机会选上。所以就是找这样的一个我，去生成下一个丑数。
说下思路，如果p是丑数，那么p=2^x * 3^y * 5^z，那么只要赋予x,y,z不同的值就能得到不同的丑数。
如果要顺序找出丑数，要知道下面几个特（fei）点（hua）。
对于任何丑数p：
a.那么2*p,3*p,5*p都是丑数，并且2*p<3*p<5*p
b.如果p<q, 那么2*p<2*q,3*p<3*q,5*p<5*q
现在说说算法思想：
由于1是最小的丑数，那么从1开始，把2*1，3*1，5*1，进行比较，得出最小的就是1的下一个丑数，也就是2*1，
这个时候，多了一个丑数‘2’，也就又多了3个可以比较的丑数，2*2，3*2，5*2，这个时候就把之前‘1’生成的丑数和‘2’生成的丑数加进来也就是(3*1,5*1,2*2，3*2，5*2)进行比较，
找出最小的。。。。如此循环下去就会发现，每次选进来一个丑数，该丑数又会生成3个新的丑数进行比较。
上面的暴力方法也应该能解决，但是如果在面试官用这种方法，估计面试官只会摇头吧。

下面说一个O（n）的算法。既然有p<q, 那么2*p<2*q，那么“我”在前面比你小的数都没被选上，
你后面生成新的丑数一定比“我”大吧，那么你乘2生成的丑数一定比我乘2的大吧，那么在我选上之后你才有机会选上。
其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的数。
其实也就是维护记住用于乘2的最小的数t2，、用于乘3的最小的数t3，用于乘5的最小的数t5。


算法核心;对于输入index，创建维护一个丑数数组大小位index的数组，返回下标为index-1的值即可
1,非法输入，index小于等于0
2,输入为1，丑数之源
3，创建一个大小为index的丑数数组res[index]
4，制定第一个丑数，res[0] = 1
5,设定要维护的，入选的乘2的最小数下标，乘3的最小数下标，乘5的最小数下标，即小于该下标的选过了，大于他的太大了，他就是入选的那个
并且初始化为0
6，循环从1开始到index-1，其实就是生成index个丑数
6.1下一个丑数，就是乘2的最小数，乘3的最小数，乘5的最小数中的最小的数
if判断，生成的这个丑数，到底是前面谁生成的，那他就可以换后面一个候选人
7，返回index-1
*/

class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        if(index <= 0){
            return 0;//非法输小于等于0
        }
        if(index == 1){//第一个丑数
            return 1;
        }
        vector<int> res(index);//创建index大小的空数组，后面就是根据1，不断乘235，生成新的丑数，并保证有序
        res[0] = 1;//数组第一个丑数为1
        int t2 = 0, t3 = 0, t5 = 0;//定义三个需要维护的用于生成的下一个有序丑数的下标
        //乘2 乘3 乘5可以分开算是因为如果p<q, 那么2*p<2*q,3*p<3*q,5*p<5*q，所以可以分别维护
        for(int i = 1; i < index; i++){//生成除了1后面的丑数
            res[i] = min(res[t2]*2, min(res[t3]*3, res[t5]*5));
            //因为t2，t3，t5已经是维护好的了，所以只需求最小
            if(res[i] == res[t2]*2){
                t2++;
            }
            if(res[i] == res[t3]*3){
                t3++;
            }
            if(res[i] == res[t5]*5){//这块就是，如果当前丑数是前面谁生成的，那他就用过了，用下一个和其他的候选者比
                t5++;
            }
        }
        return res[index - 1];//注意下标记
    }
};
