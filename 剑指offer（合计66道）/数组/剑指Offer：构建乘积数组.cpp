/*
给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],
其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。

思路：
观察下公式，你会发现，B[i]公式中没有A[i]项，也就是说如果可以使用除法，
就可以用公式B[i]=A[0]*A[1]*.....*A[n-1]/A[i]来计算B[i]，但是题目要求不能使用，因此我们只能另想办法。
现在要求不能使用除法，只能用其他方法。一个直观的解法是用连乘n-1个数字得到B[i]。显然这个方法需要O(n*n)的时间复杂度。
好在还有更高效的算法。可以把B[i]=A[0]*A[1]*.....*A[i-1]*A[i+1]*.....*A[n-1]。
看成A[0]*A[1]*.....*A[i-1]和A[i+1]*.....A[n-2]*A[n-1]两部分的乘积，即通过A[i]项将B[i]分为两部分的乘积。
总结：
1，因为B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]，可以将中间丢失的A[i]用1表示，然后画出B[i]的矩阵
2，通过矩阵观察，B[i]矩阵是一个对角为1的矩阵，其中下三角矩阵C[i]可以由上推导下，上三角矩阵D[i]反过来推导即可
3，最后合成即可，这里节省空间矩阵C可以用矩阵累计，矩阵D就是tmp矩阵
*/
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        int length = A.size();
        vector<int> B(length);//声明数组长度，并且用于创建辅助数组
        if(length <= 0){
            return B;//非法输入，返回空数组B，这里注意不能是NULL，要看返回的数据类型
        }
        B[0] = 1;//求下三角矩阵，因为是对角线为1，所有设定第一个是B[0] = 1
        for(int i = 1; i < length; i++){//从1到length-1循环遍历
            B[i] = B[i - 1] * A[i - 1];
             //其中B[i]相当于临时存储了C[i]，并且B[i]是由B[i-1]累计计算得出来的，因为A已知，起始B[0]已知
        }
        //求上三角矩阵，初始值也是1，这个直接就是用第二个for循环求出结果B了，因此不用开辟数组，直接求出B[i]即可，int足够
        int tmp = 1;
        for(int i = length - 2; i >= 0; i--){//从倒数第二个开始遍历到0，因为初始值是最后一行最后一列（值为1）
            tmp *= A[i + 1];//这个tmp在for循环中，一直在累计迭代，后面的值，无需保存，所以叫tmp，看B矩阵图解即可
            B[i] *= tmp;//合成，输出B
        }
        return B;
    }
};