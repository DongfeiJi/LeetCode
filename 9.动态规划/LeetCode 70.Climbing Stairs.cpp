/*
c++刷题答案整理：https://github.com/DongfeiJi/LeetCode
经典暴力搜索，回溯法,时间复杂度接近于2的n次方，过不掉
因此考虑动态规划算法，将原问题拆解为子问题
考虑：对于爬到第i阶，与哪些阶有关？只能是第i-1阶与第i-2阶
因此，爬到第i阶的爬法数量就等于爬到第i-1阶爬法数量+第i-2阶爬法数量
这里面找子问题，相当于找关系，结合题意
算法：(命名最好用dp，动态规划，很专业哦)
1，设置一个递推数组dp[0...n],dp[i]代表到达第i阶的爬法，初始化为0
2，设置到达第1阶，有1种爬法，到达第二阶有2种爬法
3，利用i循环递推从第3阶至第n阶结果：
    到达第i阶爬法=第i-1阶爬法+第i-2阶爬法
dp0=0；dp1=1；dp2=2;dp3=dp1+dp2=3;dpi=dp(i-1)+dp(i-2)....

*/

class Solution {
public:
    int climbStairs(int n) {
        std::vector<int> dp(n+3, 0);//不用特殊处理n=0与n=1,因为有下表i-1，i-2，防止越界
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};

/*
dp总结：
1，确认原问题与子问题，原问题是求n阶台阶走法，子问题是求n-1阶台阶走法，n-2。。。
2，确认状态，本题目状态单一，第i个状态就是第i阶台阶的走法
3，确认边界状态的值，因为边界不一定满足递推式，本题就是dp1，dp2
4，确定状态转移方程，即找到原问题，与最相近的两个子问题之间的递推关系，本题dpi=dpi-1 + dpi-2（i大于等于3）
*/