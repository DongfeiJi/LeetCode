###8、计数排序
算法描述:

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。
作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

实现逻辑:
找出待排序的数组中最大和最小的元素；
统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
对所有的计数累加(从桶中的第0个元素开始，每一项和前一项相加);
反向填充目标数组：将每个元素i放在新数组的第C(i)项,
每放一个元素就将C(i)减去1，是为了保证算法的稳定性。


(计数排序;时间A:N+k,B:N+k,E:N+k;空间N+k;稳定)

/*    
输入的元素是 n 个 0到 k 之间的整数
当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。
下面算法是输入的数组中的最小值大于等于0的情况，可以根据需求更改。    
  */

void countSort(int arr[] ,int length){
    int max = arr[0];//先初始化一个max标记为最大的数，因为要求范围
    int lastIndex=  0;
    for (int i = 1; i<length; i++) {
        max = arr[i]>max ? arr[i]:max;//初始化max是0下标，因此从1开始遍历，最大的赋值给max
    }
    int* sortArr  = new int[max+1]();//声明一个辅助数组，用来计数
    for (int j = 0; j< length; j++) {
        sortArr[arr[j]]++;//遍历原数组，构成数值哈希，key为原数组的数值，value为该值出现的次数
    }
    for (int k = 0; k<max+1; k++) {//遍历计数辅助数组
        while (sortArr[k]>0) {//凡是有值的地方，此时下标就是原数组的值
            arr[lastIndex++] = k;//将原数组下标++赋值回去，有多个就多次赋值，所以用while
            sortArr[k]--;//赋值一个，次数就--
        }
    }
}