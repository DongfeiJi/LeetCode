###希尔排序

实现逻辑:第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法流程：
选择一个递减的增量序列t1，t2，…，tk，其中ti>tj，tk=1；
按增量序列个数k，对序列进行k 趟排序；
每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
/*
    (又称缩小增量排序)
    通过实验，大量本表现出，平均时间复杂度为N^1.3
*/
    int gap = length;//初始增量值为length
    while (gap>1){
        gap = gap/3 +1;//递减的增量序列，每次对比都是跳过增量的距离进行比较
        for (int i = gap; i<length; i+=gap) {//从头到尾，以当前增量的间隔去遍历
            int current = arr[i];//当前值
            int preIndex = i - gap;//前面的值
            while (preIndex >= 0 && arr[preIndex]>current) {//从后向前比
                arr[i]  = arr[preIndex];//如果当前值current比前面的值arr[preIndex小
                preIndex -= gap;//下标迭代是根据增量的大小，那么每一位都移动赋值
            }
            arr[preIndex+gap] = current;//最后把当前值赋值给移动后的下标的下一个
        }
    }