/*
c++刷题答案；https://github.com/DongfeiJi/LeetCode
分析原题：
1，n个房间，每个房间都有盗取或者不盗取两种可能类似于子集，在不触发报警，选择总和最大的子集，时间复杂度2的n次方，如何优化？
2，贪心算法是否可行？比如满足不报警时，每次选择数值最大的进行盗取，这种肯定不行，有反例
3，dp算法，如何确定四要素，如原问题子问题，状态，边界状态，状态转移方程。
枚举找规律！！！！！！！
分析：dp算法原问题与子问题都是往前找
由于相邻房间盗取会报警：所以：1，若从第i个房间盗取，一定不能从i-1盗取。2，若不从第i个盗取，只能考虑从前i-1盗取
暴力枚举，对于第i个房间，选和不选，往前推理
算法过程：
1，原问题是求n个房间最优解，子问题是求前1个，2个。。。。n-1个房间的最优解
2，确认状态，第i个状态就是前i个房间能够获得的最大财富
3，确认边界，前1个房间最优解，就是第一个房间财富，前2个房间最优解，是max【房间1，房间2】
4，确定状态转移方程：
a，选择第i个房间：第i个房间+第i-2个房间的最优解
b，不选择第i个房间，前i-1个房间的最优解
dp状态转移方程：
dp[i] = max(dp[i-1],dp[i-2]+nums[i]);(i>=3)
*/

class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0){
            return 0;//除去0
        }
        if(nums.size() == 1){
            return nums[0];//除去1
        }
        std::vector<int> dp(nums.size(), 0);//定义空数组
        dp[0] = nums[0];
        dp[1] = std::max(nums[0], nums[1]);//边界
        for(int i=2; i < nums.size(); i++){
            dp[i] = std::max(dp[i-1], dp[i-2]+nums[i]);//递推式，这里注意，既可以设置从2开始，又可以设置从3开始
        }
        return dp[nums.size()-1];//千万不要忘记减去1，防止越界
    }
};