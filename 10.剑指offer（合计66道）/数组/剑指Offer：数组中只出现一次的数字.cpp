/*
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

首先想到顺序扫描法，时间复杂度是O（n^2）。哈希表的方法，但是空间复杂度不是O（1）。

我们可以想一想“异或”运算的一个性质。
举例：{2,4,3,6,3,2,5,5},这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？
如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。
异或性质：任何一个数字异或它自己都等于0。如果从头到尾依次异或数组中的每一个数字，最终的结果刚好是那个只出现一次的数字。
比如数组{4,5,5}，先用元素4（二进制形式：0100）和元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，
用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作得到0100，正好是结果数字4。
那么我们如何在一个数组中找到两个只出现一次的数字呢？
如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。
这样，我们就可以用上述方法找到那个孤苦伶仃的元素。

我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。
也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。
现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。
举例：{2,4,3,6,3,2,5,5}
我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。
异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。
第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。
接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。
总结：
1，判断特殊情况
2，全局异或，用来求第一个不同的位
3，调用子函数求全局第一个不同的下标位
4，声明num1，num2,调用子函数分组，直接异或分好组的数
*/
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
        int length = data.size();
        if(length <= 1){
            return;
        }
        // 对原始数组每个元素求异或，结果保存在resultExclusiveOR，用于求用来求第一个不同的位下标
        int resultExclusiveOR = 0;
        for(int i = 0; i < length; i++){
            resultExclusiveOR ^= data[i];
        }
        //调用子函数求全局第一个不同的下标位
        unsigned int indexOf1 = FindFirst1(resultExclusiveOR);//下标始终为正数，用unsigned int，这里用int也可以通过
        //声明num1，num2,调用子函数分组，直接异或分好组的数
        *num1 = *num2 = 0;
        for(int j = 0; j < length; j++){
            if(IsBit1(data[j], indexOf1)){
                *num1 ^= data[j];//0异或任何都是任何自己，所以异或结果就保存为num1了，很巧妙
            }
            else{
                *num2 ^= data[j];
            }
        }
    }
private:
    unsigned int FindFirst1(int num){// 找到二进制数num第一个为1的位数，比如0010，第一个为1的位数是2。
        unsigned int indexOf1 = 0;
        while((num & 1) == 0){//可以加&& (indexBit < 8 * sizeof(unsigned int))，这就是只判断一个字节的
            num = num >> 1;
            indexOf1++;//其实是找右边数第一个为1的位下标
        }
        return indexOf1;
    }
    bool IsBit1(int num, int indexBit){// 判断第indexBit位是否为1
        num = num >> indexBit;
        return (num & 1);//右移indexBit位，最后和1进行与操作，因为1相当于00001，所以只有第indexBit位为1，结果才是1
    }
};