/*
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，
他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：
{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，
{2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

可以使用一个双端队列deque，一般用法如下：
dq.push_front(102);///插入头部
dq.push_back(101);///插入尾部
dq.pop_back();///删除尾部
dq.pop_front();///删除头部
用STL中的deque来实现，接下来以数组{2,3,4,2,6,2,5,1}为例
数组的第一个数字是2，把它存入队列中。
第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。
第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。
第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。
下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。
但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。
当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。
算法核心：利用双端队列，时刻保证队列头部是滑动窗口最大值，并且在队列里面存的是数组的下标，利用下标差可以维护滑动窗口
1，定义结果数组
2，if判断num数组大于等于窗口size大小，并且窗口大小大于等于1
2.1，定义一个记录index的双端队列
2.2，for循环从0~size-1，先构造一个滑动窗口
2.2.1，用while循环判断，index不空+新值大于队列的最小值back
弹出最小值
2.2.2，放入新值
2.3,for循环遍历num数组从size~num.size()，维护滑动窗口
2.3.1，先把最最前面滑动窗口的最大值push到result,然后循环种不断把最最前面滑动窗口的最大值push到result，但是此时差最后一个
2.3.2，while判断，滑动窗口队列不空+当前值大于队列的最小值back
弹出最小值
2.3.3，if判断控制滑动窗口大小，滑动窗口队列不空+队列头下标 小于 当前下标减去size
此时说明该超大值，从滑动窗口滑出，pop front
2.3.4，最后在for循环外面将最后一个最大值，push到result
3，返回结果
*/
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size){
        vector<int> result;
        if(num.size() >= size && size >= 1){//// 数组大小要大于等于窗口大小，并且窗口大小大于等于1，才有意义求解
            deque<int> index;
            for(int i = 0; i < size; i++){//创建第一个滑动窗口，因为这是特殊值
                while(!index.empty() && num[i] > num[index.back()]){
                    index.pop_back();
                }//新值大于队列中最后面的最小值，将队列中最小值删除后再push新值
                index.push_back(i);
            }
            for(unsigned int i = size; i < num.size(); i++){//继续从下一个点开始计算
                //下面这句是循环push队列（滑动窗口）中的队头也就是最大值到结果
                result.push_back(num[index.front()]);//放在前面是因为前面第一个滑动窗口的最大值还没有push到result
                while(!index.empty() && num[i] >= num[index.back()]){//一定是大于等于，否则push重复了
                    index.pop_back();//新值大于队列中最后面的最小值，将队列中最小值删除后再push新值
                }
                //下面是维护滑动窗口大小，判断当前i-size后的下标在不在front前面，此时说明队列头的点滑出窗口咯
                if(!index.empty() && index.front() <= int(i - size)){
                    index.pop_front();//弹出队列头减小滑动窗口再push
                }
                index.push_back(i);
            }
            result.push_back(num[index.front()]);//补充最后一个滑动窗口的最大值
        }
        return result;
    }
};