/*
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。
但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。
没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序

设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，
由于是正数序列，所以可以把第一个数设为1，最后一个数为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。
下一步就是不断改变第一个数和最后一个数的值，如果从第一个数到最后一个数的和刚好是要求的和，
那么把所有的数都添加到一个序列中；如果大于要求的和，则说明从第一个数到最后一个数之间的范围太大，
因此减小范围，需要把第一个数的值加1，同时把当前和减去原来的第一个数的值；
如果小于要求的和，说明范围太小，因此把最后一个数加1，同时把当前的和加上改变之后的最后一个数的值。
这样，不断修改第一个数和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。
注意：初中的求和公式应该记得吧，首项加尾项的和乘以个数除以2，即sum = (a + b) * n / 2。

算法核心：维护一个滑动窗口，求和，当前和小，提高上限，当前和大提高下限，当前和等sum就push结果并且提高下限
1，定义结果数组
2，定义底位和高位指针，分别为1和2
3，while判断合法，即底位小于高位
计算当前和
如果当前和较小，phigh++
如果当前和相等，定义临时数组，push进去，再push到result，最后plow++
如果当前和较大，plow++
4，返回result
*/
class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
        vector<vector<int>> result;
        int plow = 1, phigh = 2;//初始化最小窗口
        while(plow < phigh){//满足条件的判断，因为两个指针都要++
            int cursum = (plow + phigh)*(phigh - plow + 1) >> 1;//计算当前和
            if(cursum < sum){
                phigh++;//当前和较小，因此要让右侧扩大一些
            }
            if(cursum == sum){
                vector<int> tmp;
                for(int i = plow; i <= phigh; i++){
                    tmp.push_back(i);//记录结果
                }
                result.push_back(tmp);
                plow++;//此窗口记录过不要忘记向下判断窗口
            }
            if(cursum > sum){
                plow++;//当前和较大，因此要让左侧缩小一些
            }
        }
        return result;
    }
};